---
description: >-
  Tìm hiểu về Tree (Cây) trong Data Structures and Algorithms (DSA) - Các loại cây trong DSA
title: Tree in DSA
date: 2024-11-08 12:00:00 +0700
categories: [Blog, Code]
---

Hello mn, hôm nay toi vừa fail bài test về cây huhu ;-; nên quyết định sẽ đi tổng hợp kiến thức bị hỏng của toi về cây lại tại đây. Mọi người đừng như tôi nhé :((

## **Cây là gì ?**

Theo lí thuyết đồ thị, cây là một đồ thị liên thông, vô hướng và không có chu trình.

Còn trong mặt cấu trúc dữ liệu và giải thuật, cây là một cấu trúc dữ liệu phi tuyến tính, tương tự như một linked list nhưng thay vì mỗi node chỉ đơn giản chỉ đến node tiếp theo theo kiểu tuyến tính, ở tree mỗi node trỏ đến một số node khác, phát triển theo nhiều nhánh và giúp biểu diễn các quan hệ phân cấp phức tạp. Giũa các node có quan hệ phân cấp gọi là cha - con (parent - child)

## **Tính chất và thành phần của cây**
### 1. Node (Nút)
> Mỗi phần tử trong một cây được gọi là Node (hay nút)
{: .prompt-tip }

### 2. Root (Node gốc)
> Mỗi cây đều có một node đặc biệt gọi là node root hay node gốc của cây. Node gốc là node không có cha.
{: .prompt-tip }

### 3. Parent (Node cha)
> Node trực tiếp kết nối và đứng ở cấp trên của nó gọi là node cha (parent).
{: .prompt-tip }

### 4. Child (Node con)
> Node nằm bên dưới một node khác (cha) thì gọi là node con (child)
{: .prompt-tip }

### 5. Siblings (Node anh em)
> Các node có cùng một cha (parent) gọi là anh em (siblings)
{: .prompt-tip }

> Một node con thì chỉ có thể có một node cha, nhưng một node cha thì có thể có nhiều node con.
{: .prompt-tip }

### 6. Leaf (Node lá)
> Node không có con gọi là node lá (leaf). Trong đồ thị thì nó gọi là đỉnh treo
{: .prompt-tip }

### 7. Path (Đường đi)
> Là một dãy liên tiếp các node, trong đó mỗi node trỏ tới node con của nó. Một path có thể bắt đầu từ gốc (root) và kết thúc tại một node lá (leaf), hoặc từ một node bất kỳ đến một node bất kỳ khác trong cây.
{: .prompt-tip }

### 8. Order (Bậc của cây)
> Bậc của một cây là số lượng node con tối đa có thể của node đó.
{: .prompt-tip }

> Ex: cây nhị phân (binary tree) thì chỉ có tối đa 2 con trên 1 node, tương tự với cây 3-phân,...
{: .prompt-tip }

### 9. Degree (Bậc của node)
> Bậc của một node là số lượng node con của một node cụ thể trong cây
{: .prompt-tip }

### 10. Height (Chiều cao)
> Chiều cao của cây (Height of the tree) là số cạnh trên đường đi dài nhất tính từ root đến một node lá (leaf)
{: .prompt-tip }

### 11. Level (Mức)
> Mức của cây (level): Tập hợp tất cả các node ở một độ sâu nhất định được gọi là level của cây.
  > - Tại root của cây sẽ được gán level là 0
  > - Các node trực tiếp (node con của node gốc) là mức 1
  > - Các node con của node mức 1 là mức 2, cứ thế tiếp tục
  > - ...
{: .prompt-tip }

### 12. Depth (Độ sâu)
> Độ sâu của một node là số cạnh từ root đến node đó. Node gốc có độ sâu bằng 0.
  > - Lưu ý: Độ sâu và mức (level) thường có thể trùng nhau về giá trị nhưng khác nhau về ngữ nghĩa.
  > - Mức dùng để chỉ vị trí phân cấp, còn độ sâu dùng để chỉ khoảng cách từ gốc.
{: .prompt-tip }

### 13. Ancestor (Tổ tiên)
> Một node được gọi là Ancestor (tổ tiên) (của node x nào đó trong cây) nếu nó nằm trên đường đi từ root tới node x.
  > - Node x cũng được coi là tổ tiên của chính nó (được gọi là tổ tiên bản thân hoặc trivial ancestor).
{: .prompt-tip }

### 14. Descendant (Hậu duệ)
> Một node được gọi là Descendant (hậu duệ) (của node x nào đó trong cây) nếu nó nằm trên đường đi từ node x tới node lá (leaf)
  > - Node x cũng được coi là hậu duệ của chính nó (gọi là trivial descendant).
{: .prompt-tip }

### 15. Subtree (Cây con)
> Subtree (cây con) của một node x là một cây bao gồm một node con (nếu có) của x và tất cả các hậu duệ của node con đó.
{: .prompt-tip }

> Mỗi node trong cây đều là gốc của một cây con.
{: .prompt-tip }

### 16. Internal Node (Đỉnh trong)
> Node trong (hay đỉnh trong) là node có ít nhất 1 con (tức là không phải node lá).
{: .prompt-tip }

### **Ví dụ minh họa**

![](/img/tree/treetest.png)
_Hình ảnh một cây(Tree)_

Như trên hình, ta có
> - Node [root](#2-root-node-gốc) là A (node không có node cha)
- Node [parent](#3-parent-node-cha) của F là B (tức B là node cha của F - F là node con của B)
- Node [child](#4-child-node-con) của D là H (tức H là node con của D - D là node cha của H)
- I và J là 2 anh em ([siblings](#5-siblings-node-anh-em)) và có cùng node cha là G
- [Leaf](#6-leaf-node-lá): E, F, I, J, C, M, L (các node không có node con)
- [Path](#7-path-đường-đi): A -> B -> G -> J (một đường đi từ A -> J)
- [Order](#8-order-bậc-của-cây) của cây trên hình là 3 (vì có node có bậc cao nhất là 3: A, B)
- [Degree](#9-degree-bậc-của-node) của H là 2 (vì H có 2 node con là K và L)
- [Height](#10-height-chiều-cao) của cây trên hình là 4 (vì đường đi cạnh dài nhất từ root tới leaf là: A -> D -> H -> K -> M, có 4 cạnh)
- Các node có [Level](#11-level-mức) = 2 là: E, F, G, H; [Level](#11-level) = 1 là B, C, D
- [Depth](#12-depth-độ-sâu) của B, C, D là 1 (vì cách root A 1 path)
- [Ancestor](#13-ancestor-tổ-tiên) của node G là A và B (vì tồn tại đường đi A -> B -> G)
- [Descendant](#14-descendant-hậu-duệ) của node B chính là E, F, G, I và J
- [Subtree](#15-subtree-cây-con) của D chính là cây con của D: gồm các Descendant: D, H, K, L, M
- [Internal Node](#16-internal-node-đỉnh-trong) gồm: A, B, G, D, H, K (node không phải node lá)
{: .prompt-tip }

## **Binary Tree (Cây nhị phân)**

Có nhiều loại cây khác nhau như cây thông thường, cây k-phân (nhị phân, tam phân). Tuy nhiên, ở đây chúng ta sẽ tìm hiểu sâu vào cây nhị phân (Binary Tree)

Cây nhị phân (Binary Tree) là một cây mà mỗi nút của nó chỉ có tối đa 2 node con. Các node con đó cũng được phân biệt thành node con trái và node con phải. 

Biễu diễn và lưu trữ cây:

- Thành phần của một node trong cây nhị phân:

```c++
struct Node {
  int data;
  Node* left;
  Node* right;
}
```

- Với data: giá trị mà node đó lưu trữ
- Node* left: chứa địa chỉ (con trỏ) tới nút con bên trái
- Node* right: chứa địa chỉ (con trỏ) tới nút con bên phải

- Khi duyệt, chỉ cần quan tâm tới node root, vì từ root, ta có thể di chuyển sang left và right và duyệt mọi node khác

- Ngoài ra, bạn có thể sử dụng mảng (Array) để biểu diễn cây nhị phân bằng cách:
  - Xem cây đó là một cây nhị phân hoàn hảo (Perfect Binary Tree) (Phần này sẽ được đề cập bên dưới), tức là thêm một số node giả vào để tạo thành cây nhị phân hoàn hảo (Perfect Binary Tree) và gán các giá trị giả đó bằng rỗng (null)
  - Đánh số cho node gốc là 0
  - Di chuyển xuống mức kế tiếp, đánh số lần lượt từ trái sang phải đối với các nút ở mỗi mức, kể cả nút rỗng (null) (1,2,3,...) cho đến node lá ngoài cùng nhất trên mức sâu nhất của cây.

- Với cách đánh số này, con của node thứ i sẽ là 2i+1 và 2i+2
- => lưu trữ cây bằng 1 mảng a, với node thứ i sẽ nằm ở vị trí a[i]

Ví dụ với cây bên dưới, thay vì biểu diễn bằng cây, ta có thể làm thành mảng arr[]:
![](/img/tree/treeasarray.png)

Tuy nhiên không khuyến khích sử dụng vì có thể tốn thêm vùng nhớ nếu nó không phải là cây nhị phân hoàn chỉnh (Complete Binary Tree). Một trường hợp có thể sử dụng và hiệu quả đó là cấu trúc dữ liệu Heap và Heap Sort. Bạn có thể đọc thêm tại đây: [HeapSort](https://www.geeksforgeeks.org/heap-sort/)

## **Traversal Binary Tree (Duyệt cây nhị phân)**

Traversal (Duyệt cây) là duyệt qua tất cả các node trong cây theo một thứ tự nhất định, đảm bảo rằng mỗi node đều được thăm đúng một lần.
- Có 3 cách duyệt cây nhị phân thường được sử dụng:

### 1. Pre-Order Traversal - Tiền thứ tự (NLR)

- Bước 1: Duyệt từ node root trước
- Bước 2: Duyệt qua cây con trái (Left)
- Bước 3: Duyệt qua cây con phải (Right)

> Root -> Left -> Right
{: .prompt-tip }

Bên dưới là code C++ minh họa phép duyệt tiền thứ tự (NLR):

```c++
void NLR(Node* root){
  if (root){
    cout << root -> data <<" ";
    NLR(root -> left);
    NLR(root -> right);
  }
}
```

### 2. In-Order Traversal - Trung thứ tự (LNR)

- Bước 1: Duyệt từ cây con trái trước (Left Subtree)
- Bước 2: Duyệt qua node gốc (Root)
- Bước 3: Duyệt qua cây con phải (Right Subtree)

> Left -> Root -> Right
{: .prompt-tip }

Bên dưới là code C++ minh họa phép duyệt trung thứ tự (LNR):

```c++
void LNR(Node* root){
  if (root){
    LNR(root -> left);
    cout << root -> data <<" ";
    LNR(root -> right);
  }
}
```

### 3. Post-Order Traversal - Hậu thứ tự (LRN)

- Bước 1: Duyệt từ cây con trái trước (Left Subtree)
- Bước 2: Duyệt qua qua cây con phải (Right Subtree)
- Bước 3: Duyệt qua node gốc (Root)

> Left -> Right -> Root
{: .prompt-tip }

Bên dưới là code C++ minh họa phép duyệt hậu thứ tự (LRN):

```c++
void LRN(Node* root){
  if (root){
    LRN(root -> left);
    LRN(root -> right);
    cout << root -> data <<" ";
  }
}
```

### 4. Ví dụ minh họa phép duyệt cây nhị phân

![](/img/tree/binarysearchtree.png)
_Binary Tree_

> - Pre-Order Traversal: 50 20 10 5 15 30 80 75 90 85
- In-Order Traversal: 5 10 15 20 30 50 75 80 85 90
- Post-Order Traversal: 5 15 10 30 20 75 85 90 80 50
{: .prompt-tip }

Bạn có thể xem video này để hiểu rõ hơn về cách duyệt
{% include embed/youtube.html id='rPCtxUBTl8w' %}

- Ngoài ra các cách duyệt trên vẫn có thể áp dụng cho cây k-phân, bạn có thể đọc thêm tại đây: 
  - [Inorder Traversal of an n-ary tree](https://www.geeksforgeeks.org/inorder-traversal-of-an-n-ary-tree/)
  - [Preorder Traversal of an n-ary tree](https://www.geeksforgeeks.org/construct-full-k-ary-tree-preorder-traversal/)
  - [Postorder Traversal of an n-ary tree](https://www.geeksforgeeks.org/iterative-postorder-traversal-of-n-ary-tree/)

### 5. Polish Notation và Reverse Polish Notation

Một trong những ứng dụng của phép duyệt cây chính là Polish Notation (Ký pháp Ba Lan) và Reverse Polish Notation (Ký pháp Ba Lan ngược)

> Trước hết, ta có định nghĩa của cây nhị phân biểu thức (Binary expression tree) chính là cây nhị phân mà:
- Mỗi số được biểu diễn bởi 1 node lá (leaf)
- Mỗi đỉnh trong (node trong) biểu diễn một toán tử với 2 thành tố là 2 node con của đỉnh ấy
{: .prompt-tip }

Kết quả thu được sau khi duyệt cây nhị phân biểu thức bằng phép duyệt tiền thứ tự (Preorder Traversal) là tiền tố (gọi là Ký pháp Ba Lan - Polish Notation)

Tương tự như vậy với phép duyệt hậu thứ tự (Postorder Traversal) là hậu tố (gọi là Ký pháp Ba Lan ngược - Reverse Polish Notation)

Ví dụ minh họa cho cây nhị phân biểu thức:

![](/img/tree/binaryexpressiontree.png)
_Cây nhị phân biểu thức_

- Kết quả của phép duyệt tiền tự: 

```
+ ^ * 3 2 2 / 25 - 9 4
```

- Kết quả của phép duyệt hậu tự: 

```
3 2 * 2 ^ 25 9 4 - / +
```

Để tính các Ký pháp Ba Lan và Ký pháp Ba Lan ngược ở trên, ta sẽ dùng tính chất của stack để giải quyết:

+ Đối với Ký pháp Ba Lan

> - Duyệt từ phải sang trái.
- Nếu gặp toán hạng, đẩy vào stack.
- Nếu gặp toán tử, lấy các toán hạng cần thiết từ đỉnh stack, thực hiện phép toán, và đẩy kết quả trở lại stack.
- Kết quả cuối cùng sẽ nằm ở đỉnh stack sau khi duyệt hết biểu thức.
{: .prompt-tip }

+ Đối với Ký pháp Ba Lan ngược

> - Duyệt từ trái sang phải.
- Nếu gặp toán hạng (số), đẩy vào stack.
- Nếu gặp toán tử, lấy các toán hạng cần thiết từ đỉnh stack để thực hiện phép toán, sau đó đẩy kết quả trở lại stack.
- Sau khi duyệt hết biểu thức, kết quả cuối cùng sẽ nằm ở đỉnh stack.
{: .prompt-tip }

Demo sử dụng Stack
```
PostOrder Traversal
Biểu thức = 3 2 * 2 ^ 25 9 4 - / +
Stack = []

#L1
Biểu thức = 2 * 2 ^ 25 9 4 - / +
Stack = [3]

#L2
Biểu thức = * 2 ^ 25 9 4 - / +
Stack = [3, 2]

#L3
Biểu thức = 2 ^ 25 9 4 - / +
Stack = [3, 2, *]

Ở đây gặp toán tử, ta tính các số có trong stack với nhau, ở đây sẽ là 3 * 2 = 6
Sau khi tính xong thì pop các số và toán tử vừa tính ra, push 6 (là kết quả vừa xử lí) vào lại stack
Stack = [6]

#L4
Biểu thức = ^ 25 9 4 - / +
Stack = [6, 2]

#L5
Biểu thức = 25 9 4 - / +
Stack = [6, 2, ^]

Lại gặp toán hạng, ta xử lí: 6 ^ 2 = 36, pop 6,2,^ ra, push 36 vào stack
Stack = [36]

#L6
Biểu thức = 9 4 - / +
Stack = [36, 25]

#L7
Biểu thức = 4 - / +
Stack = [36, 25, 9]

#L8
Biểu thức = - / +
Stack = [36, 25, 9, 4]

#L9
Biểu thức = / +
Stack = [36, 25, 9, 4, -]

Ở đây ta xử lí 9 - 4 = 5, sau đó pop 9, 4, - ra và push 5 vào
Stack = [36, 25, 5]

#L10
Biểu thức = +
Stack = [36, 25, 5, /]

Tương tự, 25/5 = 5, pop 25,5,/, push 5 vào
Stack = [36,5]

#L11
Biểu thức = 
Stack = [36 5 +] => 36 + 5 = 41, pop 36,5,+, push 41 vào
Thuật toán dừng lại do biểu thức đã hết toán tử và toán hạng 
Stack = [41], trả kết quả đỉnh stack là 41 
```

+ Đối với cách làm nhanh (trên giấy hoặc nhẩm)

> Gặp phép toán thì lấy 2 giá trị liền kề trước đó (hoặc sau đó) để tính xong viết lại kết quả vừa tính vào biểu thức
{: .prompt-tip }

Demo cách nhẩm/làm giấy

```
PostOrder Traversal
3 2 * 2 ^ 25 9 4 - / +
=> (3 2 *) 2 ^ 25 (9 4 -) / +
=> 6 2 ^ 25 5 / +
=> (6 2 ^) (25 5 /) +
=> 36 5 +
=> (36 5 +) = 41
```

Ở trên là Demo về các cách tính biểu thức từ phép duyệt hậu tự, các bạn có thể tự làm với phép duyệt tiền tự (nhớ tuân theo quy tắc duyệt ở trên mình đã đề cập)

## Types of Binary Trees (Các loại cây nhị phân)

### 1. Skewed Binary Tree (Cây nhị phân lệch)

Cây nhị phân lệch (Skewed Binary Tree) là cây mà cây nhị phân trong đó tất cả các nút chỉ có một nút con hoặc không có nút con.

Nó có thể chuyển thành một danh sách liên kết (linked list) vì tất cả các node chỉ có một nhánh con duy nhất (trái hoặc phải).

Có 2 loại đặc biệt: Left Skewed Binary Tree và Right Skewed Binary Tree

![](/img/tree/skewed-tree.png)
_Nguồn: Geeksforgeeks_

### 2. Complete Binary Tree (Cây nhị phân hoàn chỉnh)

Cây nhị phân hoàn chỉnh (Complete Binary Tree) là một cây nhị phân mà trong đó tất cả các mức của nó đều phải có đủ 2 node con, trừ mức cuối cùng. Mức cuối cùng của cây có thể không đầy đủ các nút con, nhưng các nút phải nằm ở vị trí bên trái càng nhiều càng tốt, nghĩa là các nút được thêm vào theo thứ tự từ trái sang phải.

Cây nhị phân hoàn chỉnh có thể biểu diễn dưới dạng mảng (array-based representation) 1 cách dễ dàng vì các nút của cây hoàn chỉnh có thể dễ dàng ánh xạ sang các chỉ số mảng.

Cấu trúc dữ liệu Heap cũng là một dạng cây nhị phân hoàn chỉnh.

![](/img/tree/Complete-Binary-Tree.webp)
_Complete Binary Tree - Source: Programiz_

![](/img/tree/complete-binary-tree-array.webp)
_Array-based representation - Source: Programiz_

![](/img/tree/no-cbt.webp)
_Not Complete Binary Tree - Source: Programiz_

Trong bức ảnh cuối, cấu trúc cây không thỏa mãn tính chất của một cây nhị phân hoàn chỉnh. Theo định nghĩa, cây nhị phân hoàn chỉnh phải được lấp đầy từ trái sang phải ở mỗi mức. Tuy nhiên, node cha có giá trị 3 lại có node con bên phải nhưng thiếu node con bên trái, vi phạm quy tắc điền đầy từ trái sang phải ở mức cuối cùng."

### 3. Full Binary Tree (Cây nhị phân đầy đủ)

Cây nhị phân đầy đủ (Full Binary Tree) là một loại cây nhị phân đặc biệt trong đó mỗi node cha có hai hoặc không có node con. (Chỉ 2 node hoặc 0 node con nào, 1 node thì không phải là Full Binary Tree)

> Tức là, chỉ cần cây đó có bất kì node cha nào chỉ có duy nhất 1 node con (trái hoặc phải đều được) thì đó không phải là Full Binary Tree
{: .prompt-tip }

Nó còn được biết đến với tên gọi là cây nhị phân thích hợp (Proper Binary Tree)

![](/img/tree/full_bt.webp)
_Full Binary Tree - Source: Programiz_

![](/img/tree/fullbt-notcbt.webp)
_This is Full Binary Tree but isn't Complete Binary Tree - Source: Programiz_

![](/img/tree/no-cbt.webp)
_Not Full Binary Tree and Not Complete Binary Tree - Source: Programiz_

![](/img/tree/fbt-and-cbt.webp)
_Full Binary Tree and also Complete Binary Tree - Source: Programiz_

### 4. Perfect Binary Tree (Cây nhị phân hoàn hảo)

Cây nhị phân hoàn hảo (Perfect Binary Tree) à một cây nhị phân mà tất cả các node trong cây đều có đúng hai node con (một node trái và một node phải), và tất cả các lá đều nằm ở cùng một mức .

> Cây nhị phân hoàn hảo cũng chính là cây nhị phân hoàn chỉnh và cây nhị phân đầy đủ.

Đặc điểm:
  + Nếu chiều cao của cây là h (tính từ mức gốc là 0), thì tổng số nút trong cây sẽ là 2<sup>h+1</sup> - 1.
  + Số node lá trong cây là 2<sup>h
  + Một cây nhị phân hoàn hảo với <i>n</i> nodes thì sẽ có chiều cao (height) là log(n + 1) - 1 = Θ(ln(n))
  (log ở đây là log cơ số 2)

![](/img/tree/pbt.png)
_Perfect Binary Tree - Source: Programiz_

> Ảnh bên trên vừa là cây nhị phân hoàn hảo, vừa là cây nhị phân đầy đủ, cũng vừa là cây nhị phân hoàn chỉnh đấy.
{: .prompt-tip }

## Binary Search Tree (BST - Cây nhị phân tìm kiếm)
### 1. BST là gì ? Tính chất và đặc điểm

Cây nhị phân tìm kiếm (Binary Search Tree) là một cấu trúc dữ liệu được sử dụng để tổ chức và lưu trữ dữ liệu theo cách được sắp xếp. Cây nhị phân tìm kiếm có tính chất đặc trưng:

> Node con bên trái luôn nhỏ hơn node cha và node con bên phải luôn lớn hơn node cha.
{: .prompt-tip }

Cụ thể:
  + Cây con bên trái của node root chỉ được chứa các giá trị nhỏ hơn node root.
  + Cây con bên phải của node root chỉ được chứa các giá trị lớn hơn node root.
  + Trong cây nhị phân tìm kiếm không được có các node có giá trị trùng lặp
  + Các thuộc tính của cây nhị phân tìm kiếm là đệ quy: nếu chúng ta coi bất kỳ node nào là "root", các thuộc tính này sẽ vẫn đúng.

> Cây nhị phân tìm kiếm là cây sắp xếp các phần tử theo một thứ tự nào đó, trong khi cây nhị phân không theo bất kỳ thứ tự nào.
{: .prompt-tip }

![](/img/tree/bst-1.png)
_Binary Search Tree - Source: Geeksforgeeks_

### 2. Các thao tác chính trên Cây nhị phân Tìm kiếm
Ta có cấu tạo của một node trong BST:

```c++
struct Node {
  int data;
  Node* left;
  Node* right;
}
```

và hàm cấp phát động cho node

```c++
Node* createNode (int data){
    Node* newNode = new Node;
    newNode -> data = data;
    newNode -> left = nullptr;
    newNode -> right = nullptr;
    return newNode;
}
```

#### a. Insert - Chèn một node vào BST
Khi chèn một node vào BST thì phải tuân theo quy tắc của BST:

> Node con bên trái luôn nhỏ hơn node cha và node con bên phải luôn lớn hơn node cha.

Thuật toán sẽ dừng lại khi tìm được vị trí thích hợp cho node đó trong cây. Cụ thể, quá trình chèn một node mới vào BST diễn ra như sau:

1. Bắt đầu từ node gốc (root) của cây.
2. So sánh giá trị của node mới với giá trị của node hiện tại:
  - Nếu giá trị của node mới nhỏ hơn giá trị của node hiện tại, di chuyển sang cây con bên trái.
  - Nếu giá trị của node mới lớn hơn giá trị của node hiện tại, di chuyển sang cây con bên phải.
3. Lặp lại bước 2 cho đến khi tìm được vị trí thích hợp:
  - Nếu cây con bên trái hoặc bên phải là null, chèn node mới vào vị trí đó.
4. Node mới sẽ trở thành node con của node hiện tại tại vị trí thích hợp.

Quá trình này đảm bảo rằng BST vẫn duy trì được tính chất của nó sau khi chèn node mới.

```c++
Node* insertBST(Node*& root, int data){
    if (root == nullptr){
        root = createNode(data);
    }
    else if (data > root -> data){
        root -> right = insertBST(root -> right, data);
    }
    else {
        root -> left = insertBST(root -> left, data);
    }
    return root;
}
```

#### b. Search - Tìm kiếm một node trong BST

Tương tự như chèn, tìm kiếm cũng tuân theo quy tắc của BST như trên

Thuật toán sẽ dừng lại khi không tìm thấy node đó hoặc tìm được giá trị cần tìm

```c++
Node* searchBST(Node* root, int data){
    if (root == nullptr || root -> data == data){
        return root;
    }
    else if (data > root -> data){
        return searchBST(root -> right, data);
    }
    else {
        return searchBST(root -> left, data);
    }
}
```

#### c. Height of BST - Chiều cao của BST

Nguyên tắc:
+ Nếu root == nullptr, tức là không tồn tại gốc => không có cây => height = 0.
+ Nếu root != nullptr thì dùng đệ quy để đi qua hết cây con bên trái, trả về chiều cao của cây con trái.
+ Dùng đệ quy để đi qua hết cây con bên phải, trả về chiều cao của cây con phải.
+ Lấy giá trị lớn nhất giữa 2 giá trị vừa tìm được, sau đó cộng thêm 1 (để bao gồm cả node root trong chiều cao của cây).

```c++
int heightBST(Node* root){
    if (root == nullptr) return 0;

    int leftHeight = heightBST(root -> left);
    int rightHeight = heightBST(root -> right);

    return 1 + max(leftHeight, rightHeight);
}
```

#### d. Delete - Xóa một node trong BST

Có 3 trường hợp sẽ gặp khi xóa một node trong BST:
+ Xóa node là node lá
+ Xóa node có một node con
+ Xóa node có hai node con

**TH1: Node xóa là node lá**
  + Trường hợp này là trường hợp đơn giản nhất, chỉ việc tìm node đó xong delete thôi, vì nó là node lá nên khi xóa cũng không ảnh hưởng các node khác.

**TH2: Node xóa có 1 node con**
  + Trường hợp này, ta sẽ thay thế node cần xóa bằng node con của nó. Nếu node con là node trái hoặc node phải, ta chỉ cần cập nhật con trỏ của node cha để trỏ đến node con của node cần xóa.

**TH3: Node xóa có 2 node con**
  + Trường hợp này phức tạp hơn, ta cần tìm node nhỏ nhất trong cây con bên phải của node cần xóa (hoặc node lớn nhất trong cây con bên trái), sau đó thay thế giá trị của node cần xóa bằng giá trị của node đó, và cuối cùng xóa node đó đi.
  
```c++
Node* deleteBST(Node*& root, int data){
    if (data > root -> data){
        root -> right = deleteBST(root -> right, data);
    }
    else if (data < root -> data){
        root -> left = deleteBST(root -> left, data);
    }
    else {
        if (root -> left == nullptr){
            Node* rightNode = root -> right;
            delete root;
            return rightNode;
        }
        else if (root -> right == nullptr){
            Node* leftNode = root -> left;
            delete root;
            return leftNode;
        }
        else {
            Node* minRightNode = root -> right;
            while (minRightNode && minRightNode -> left != nullptr){
                minRightNode = minRightNode -> left;
            }
            root -> data = minRightNode -> data;
            root -> right = deleteBST(root -> right, root -> data);
        }
    }
    return root;
}
```

Các bạn có thể xem hình ảnh minh họa các thao tác tại đây: [Programiz](https://www.programiz.com/dsa/binary-search-tree)

#### e. Traversal - Duyệt

Click here => [Traversal in BST](#traversal-binary-tree-duy%E1%BB%87t-c%C3%A2y-nh%E1%BB%8B-ph%C3%A2n)

## Balanced Binary Tree (Cây nhị phân cân bằng)

Cây nhị phân cân bằng là một loại cây nhị phân mà sự chênh lệch chiều cao giữa cây con trái và cây con phải của bất kỳ node nào không vượt quá một giá trị nhất định (thường là 1). Điều này giúp đảm bảo rằng các thao tác như tìm kiếm, chèn và xóa có thời gian thực hiện là O(log n). 

### 1. AVL Tree (Adelson-Velsky Landis - Cây AVL)

Cây AVL là một loại cây nhị phân tìm kiếm (BST) tự cân bằng, được đặt theo tên của hai nhà khoa học người Nga Adelson-Velsky và Landis, những người đã phát minh ra nó vào năm 1962. Cây AVL đảm bảo rằng chiều cao của cây luôn được giữ ở mức tối thiểu, giúp các thao tác tìm kiếm, chèn và xóa có thời gian thực hiện là O(log n).

![](/img/tree/avl.webp)
_AVL Tree - Source: Programiz_

![](/img/tree/not-avl.png)
_Not AVL Tree - Source: Programiz_

#### a. Tính chất của cây AVL

> Đối với mỗi node trong cây AVL, độ cao của cây con bên trái và cây con bên phải của node đó chỉ chênh lệch tối đa là 1.
{: .prompt-tip }

#### b. Độ cao của cây AVL

Cây AVL là một cây nhị phân tìm kiếm tự cân bằng. Để duy trì tính chất cân bằng, chiều cao của các cây con của mỗi nút không được chênh lệch quá 1.

> Fact: Độ cao của một cây AVL có n nodes là O(log n).
{: .prompt-tip }

> Chứng minh (bằng quy nạp): 
- Giả sử n(h) là số node tối thiếu mà một cây AVL có chiều cao h có thể chứa được.
- Ta dễ dàng thấy rằng với `h = 1` thì `n(1) = 1` (cây có 1 node duy nhất là node gốc) và `h = 2` thì `n(2) = 2` (tức cây có gốc và một cây con có đúng một nút)
- Với `h > 2`, ta sẽ có 1 cây AVL có chiều cao h gồm: 
  + Node root
  + Hai cây con AVL, một cây con AVL có chiều cao `h-1` và một cây con khác có chiều cao `h-2`.
- Nghĩa là, `n(h) = 1 + n(h-1) + n(h-2)` với `h > 2`
- Và `n(h-1) > n(h-2)`, ta được `n(h) > 2n(h-2)`. 
- => Vì thế `n(h) > 2n(h-2), n(h) > 4n(h-4), n(h) > 8n(n-6)`,… 
- Tổng quát hóa bằng quy nạp ta có: n(h) > 2<sup>i</sup> n(h - 2i)
- Giải trường hợp cơ sở (`h - 2i = 1 => i = h/2 - 1`) ta được: n(h) > 2<sup>h/2 - 1</sup>
- Lấy logarit để tính chiều cao: `h < 2log(n(h)) +2`
- => Do đó chiều cao của cây AVL là `O(log n)`
{: .prompt-info }

Bạn có thể xem video này để hiểu hơn:
{% include embed/youtube.html id='UPyTwASOdnM' %}

Mình thấy đây cũng là một chủ đề khá thú vị, các bạn có thể xem thêm bên dưới, mình thấy có cả những cách chứng minh theo kiểu dãy Fibonacci (Nếu rảnh chắc mình sẽ research và làm 1 bài riêng hehe): 

- [AVL Height of the Tree - CSUMD](https://www.cs.umd.edu/class/fall2019/cmsc420-0201/Lects/lect05-avl.pdf)
- [PDF - 1 - ICS](https://ics.uci.edu/~goodrich/teach/cs260P/notes/AVLTrees.pdf)
- [PDF - 2 - MIT](https://people.csail.mit.edu/alinush/6.006-spring-2014/avl-height-proof.pdf)

```
"Prove the formula for the height of an AVL tree"
```

#### c. Các thao tác trên cây AVL

##### **Xoay (Rotation)**

Phép xoay cây là một trong những điểm đặc trưng của cây AVL, giúp duy trì tính cân bằng của cây sau khi thực hiện các thao tác chèn hoặc xóa.

1. **Xoay trái (Left Rotation)**: Được sử dụng khi cây con bên phải của một node có chiều cao lớn hơn cây con bên trái, gây mất cân bằng. Phép xoay trái sẽ chuyển node con bên phải thành node cha và node cha thành node con bên trái của node mới.

2. **Xoay phải (Right Rotation)**: Được sử dụng khi cây con bên trái của một node có chiều cao lớn hơn cây con bên phải, gây mất cân bằng. Phép xoay phải sẽ chuyển node con bên trái thành node cha và node cha thành node con bên phải của node mới.

3. **Xoay trái-phải (Left-Right Rotation)**: Được sử dụng khi cây con bên trái của một node có cây con bên phải cao hơn cây con bên trái. Phép xoay này bao gồm một phép xoay trái trên cây con bên trái, sau đó là một phép xoay phải trên node cha.

4. **Xoay phải-trái (Right-Left Rotation)**: Được sử dụng khi cây con bên phải của một node có cây con bên trái cao hơn cây con bên phải. Phép xoay này bao gồm một phép xoay phải trên cây con bên phải, sau đó là một phép xoay trái trên node cha.

_Bạn có thể xem video này để hiểu hơn về phép xoay cây AVL_
{% include embed/youtube.html id='M2_hILWHVfw' %}

**Các hàm phụ trợ:**

```c++
int getHeight(Node* root){
    if (!root) return 0;
    return root -> height;
}

int getBalance(Node* root){
    if(!root) return 0;
    return getHeight(root -> left) - getHeight(root -> right);
}
```
+ Hàm getHeight sẽ trả về độ cao của cây
+ Hàm getBalanced sẽ trả về hệ số cân bằng, tức là sự chênh lệch chiều cao giữa cây con trái và cây con phải. Trong cây AVL, hệ số cân bằng chỉ có thể nhận giá trị 1, 0, -1. Ngoài 3 giá trị này là cây sẽ bị không cân bằng và cần thực hiện phép xoay.

**Thao tác xoay phải (Left Rotate):**

```c++
Node* rightRotate(Node* unbalancedNode){
    Node* newParentNode = unbalancedNode -> left;
    unbalancedNode -> left = newParentNode -> right;
    newParentNode -> right = unbalancedNode;

    unbalancedNode -> height = 1 + max(getHeight(unbalancedNode -> left), getHeight(unbalancedNode -> right));
    newParentNode -> height = 1 + max(getHeight(newParentNode -> left), getHeight(newParentNode -> right));

    return newParentNode;
}
```

+ Khởi tạo node `newParentNode`, đây sẽ là node cha mới sau khi xoay xong.
+ Lấy `newParentNode = unBalanced -> left`. Tức là gán cây con trái của node mất cân bằng cho `newParentNode`.
+ Gán `unBalanced -> left = newParentNode -> right`. Tức là cây con phải của `newParentNode` sẽ trở thành cây con trái của `unBalanced`.
+ Gán `newParentNode -> right = unBalanced`. Tức là `unBalanced` sẽ trở thành cây con phải của `newParentNode`.
+ Cập nhật lại chiều cao của `unBalanced` và `newParentNode`.

**Thao tác xoay trái (Right Rotate):**

```c++
Node* leftRotate(Node* unbalancedNode){
    Node* newParentNode = unbalancedNode -> right;
    unbalancedNode -> right = newParentNode -> left;
    newParentNode -> left = unbalancedNode;

    unbalancedNode -> height = 1 + max(getHeight(unbalancedNode -> left), getHeight(unbalancedNode -> right));
    newParentNode -> height = 1 + max(getHeight(newParentNode -> left), getHeight(newParentNode -> right));

    return newParentNode;
}
```
+ Khởi tạo node `newParentNode`, đây sẽ là node cha mới sau khi xoay xong.
+ Lấy `newParentNode = unBalanced -> right`. Tức là gán cây con phải của node mất cân bằng cho `newParentNode`.
+ Gán `unBalanced -> right = newParentNode -> left`. Tức là cây con trái của `newParentNode` sẽ trở thành cây con phải của `unBalanced`.
+ Gán `newParentNode -> left = unBalanced`. Tức là `unBalanced` sẽ trở thành cây con trái của `newParentNode`.
+ Cập nhật lại chiều cao của `unBalanced` và `newParentNode`.

##### **Kiểm tra hằng số cân bằng**

Hàm này dùng để kiểm tra hằng số cân bằng để quyết định xem cây có cân bằng không, nếu cây không cân bằng thì sẽ thực hiện các phép xoay cây.

```c++
Node* checkBalanced(Node* root) {
    root->height = 1 + max(getHeight(root->left), getHeight(root->right));
    int balance = getBalance(root);

    // left left
    if (balance > 1 && getBalance(root->left) >= 0) {
        return rightRotate(root);
    }

    // left right
    if (balance > 1 && getBalance(root->left) < 0) {
        root->left = leftRotate(root->left);
        return rightRotate(root);
    }

    // right right
    if (balance < -1 && getBalance(root->right) <= 0) {
        return leftRotate(root);
    }

    // right left
    if (balance < -1 && getBalance(root->right) > 0) {
        root->right = rightRotate(root->right);
        return leftRotate(root);
    }

    return root;
}
```
##### **Chèn (Insertion)**

Khi chèn một node mới vào cây AVL, ta thực hiện các bước sau:
1. Chèn node mới vào cây như trong cây nhị phân tìm kiếm (BST). Click vào đây để xem lại => [Insert in BST](#a-insert---ch%C3%A8n-m%E1%BB%99t-node-v%C3%A0o-bst)
2. Kiểm tra và cập nhật lại độ cao của các node.
3. Kiểm tra sự cân bằng của các node, nếu có node mất cân bằng, thực hiện các phép quay (rotation) để cân bằng lại cây. (Như phần Insert của cây AVL)

```c++
Node* insertAVL(Node*& root, int data){
    if (!root){
        root = createNode(data);
    }
    else if (data > root -> data){
        root -> right = insertAVL(root -> right, data);
    }
    else {
        root -> left = insertAVL(root -> left, data);
    }

    return checkBalanced(root);
}
```

##### **Xóa (Deletion)**

Khi xóa một node khỏi cây AVL, ta thực hiện các bước sau:
1. Xóa node như trong cây nhị phân tìm kiếm (BST) => click vào đây để xem lại => [Delete in BST](#d-delete---x%C3%B3a-m%E1%BB%99t-node-trong-bst)
2. Kiểm tra và cập nhật lại độ cao của các node.
3. Kiểm tra sự cân bằng của các node, nếu có node mất cân bằng, thực hiện các phép quay (rotation) để cân bằng lại cây.

```c++
Node* deleteAVL(Node*& root, int data){
    if (data > root -> data){
        root -> right = deleteAVL(root -> right, data);
    }
    else if (data < root -> data){
        root -> left = deleteAVL(root -> left, data);
    }
    else {
        if (root -> left == nullptr){
            Node* rightNode = root -> right;
            delete root;
            return rightNode;
        }
        else if (root -> right == nullptr){
            Node* leftNode = root -> left;
            delete root;
            return leftNode;
        }
        else {
            Node* minRightNode = root -> right;
            while (minRightNode && minRightNode -> left != nullptr){
                minRightNode = minRightNode -> left;
            }
            root -> data = minRightNode -> data;
            root -> right = deleteAVL(root -> right, root -> data);
        }
    }

    if (root == nullptr) return root;
    return checkBalanced(root);
}
```

##### **Tìm kiếm (Search)**

Tìm kiếm trong cây AVL tương tự như trong cây nhị phân tìm kiếm (BST) vì nó không làm thay đổi gì với cây AVL cả, với thời gian thực hiện là O(log n). Ấn vào đây để xem lại => [Search](#b-search---t%C3%ACm-ki%E1%BA%BFm-m%E1%BB%99t-node-trong-bst)

### 2. Red-Black Tree (Cây đỏ-đen)

Cây đỏ-đen là một loại cây nhị phân tìm kiếm tự cân bằng, trong đó mỗi node có một thuộc tính màu sắc (đỏ hoặc đen). Cây đỏ-đen được sử dụng rộng rãi trong các ứng dụng yêu cầu thao tác tìm kiếm, chèn và xóa nhanh chóng, như trong các bộ nhớ đệm, cơ sở dữ liệu và hệ thống tệp.

#### a. **Tính chất**

1. Mỗi node đều có màu đỏ hoặc đen.
2. Node gốc (root) luôn có màu đen.
3. Tất cả các node lá (leaf) đều có màu đen (các node lá là các node null).
4. Nếu một node có màu đỏ, thì cả hai node con của nó đều có màu đen (không có hai node đỏ liên tiếp trên một đường đi từ gốc đến lá).
5. Đường đi từ một node bất kỳ đến các node lá của nó đều chứa cùng số lượng node đen.

![](/img/tree/Red%20Black%20Tree%200.webp)
_Red Black Tree - Source: Programiz_

> luoi wa, minh de cac dac diem chinh thoi nha

[Red Black Tree](https://www.programiz.com/dsa/red-black-tree)

#### b. **Các thao tác chính trên cây đỏ-đen**

1. **Chèn (Insertion)**:
  x- Bắt đầu từ node gốc, tìm vị trí thích hợp để chèn khóa mới.
  - Chèn node mới vào vị trí tìm được và gán màu đỏ cho node mới.
  - Kiểm tra và sửa chữa cây để đảm bảo tính chất của cây đỏ-đen:
    + - Nếu node cha của node mới là màu đen, cây vẫn cân bằng.
    + - Nếu node cha của node mới là màu đỏ, thực hiện các bước sửa chữa (xoay và đổi màu) để đảm bảo không có hai node đỏ liên tiếp và tính chất của cây đỏ-đen được duy trì.

2. **Xóa (Deletion)**:
  - Bắt đầu từ node gốc, tìm khóa cần xóa.
  - Nếu khóa nằm trong node lá, xóa khóa đó.
  - Nếu khóa nằm trong node không phải là lá, thay thế khóa đó bằng khóa lớn nhất trong cây con bên trái hoặc khóa nhỏ nhất trong cây con bên phải, sau đó xóa khóa thay thế.
  - Kiểm tra và sửa chữa cây để đảm bảo tính chất của cây đỏ-đen:
    + - Nếu node bị xóa hoặc node thay thế là màu đen, thực hiện các bước sửa chữa (xoay và đổi màu) để đảm bảo không có hai node đỏ liên tiếp và tính chất của cây đỏ-đen được duy trì.

3. **Đổi màu (Recoloring)**:
  - Được sử dụng để duy trì tính chất của cây đỏ-đen sau khi thực hiện các thao tác chèn hoặc xóa.
  - Đổi màu của các node để đảm bảo không có hai node đỏ liên tiếp và số lượng node đen trên mỗi đường đi từ gốc đến lá là như nhau.

### 3. AA Tree (Arne Andersson - Cây AA)
Cây AA là một loại cây nhị phân tìm kiếm tự cân bằng, được phát minh bởi Arne Andersson vào năm 1993. Cây AA là một biến thể đơn giản hóa của cây đỏ-đen, với mục tiêu giảm bớt độ phức tạp của các thao tác cân bằng cây.

#### a. **Tính chất**

Liên kết thông thường (link) là liên kết giữa một node cha và một node con có mức nhỏ hơn một đơn vị

Liên kết ngang (horizontal link) là liên kết giữa một node con cha và một node ở cùng một mức

1. Mỗi node lá có level bằng 1.
2. Level của mỗi node con trái luôn nhỏ hơn chính xác 1 đơn vị so với level của node cha.
3. Level của mỗi node con phải bằng hoặc nhỏ hơn 1 đơn vị so với level của node cha.
4. Liên kết ngang phải là liên kết phải. (Tức là nếu có liên kết ngang, nó phải là liên kết giữa một node và node con phải của nó).
5. Level của mỗi node con phải của con phải luôn nhỏ hơn level của node ông.
6. Không có hai liên kết ngang liên tiếp.
7. Mỗi node có level lớn hơn 1 luôn có hai node con.

![](/img/tree/aa-tree.png)
_Cây AA_

#### b. **Các thao tác trong cây AA**

**1. Skew - Xoay trái một node trong AA Tree**

Skew là một bước trong quá trình cân bằng lại AA Tree. Khi một node có cùng level với con trái của nó, ta thực hiện xoay trái node đó để đảm bảo tính chất của AA Tree. Điều này giúp loại bỏ các liên kết ngang trái, giữ cho cây luôn cân bằng.

**2. Split - Xoay phải một node trong AA Tree**

Split là một bước khác trong quá trình cân bằng lại AA Tree. Khi một node có cùng level với con phải của nó và con phải của con phải của nó, ta thực hiện xoay phải node đó và tăng level của node mới lên. Điều này giúp loại bỏ các liên kết ngang phải, giữ cho cây luôn cân bằng.

**3. Chèn (Insert):**

- Chèn node mới giống như trong BST: tìm vị trí thích hợp để chèn node mới dưới dạng một node lá.
Sau khi chèn, cần duy trì tính chất của cây AA bằng cách thực hiện các thao tác cân bằng (như skew và split).
- Skew: Khắc phục các trường hợp node trái có level bằng level của node cha. Thực hiện xoay phải node trái để đảm bảo tính cân bằng.
- Split: Áp dụng khi node có hai node con phải liên tiếp cùng level. Thực hiện tách bằng cách nâng node con phải lên, giữ cho cây luôn tuân theo các quy tắc của cây AA.

**4. Xóa (Delete):**

- Tìm node cần xóa giống như trong BST.
- Nếu node là lá, xóa trực tiếp; nếu không, thay thế giá trị bằng node lá phù hợp (có thể là node lá nhỏ nhất bên phải hoặc lớn nhất bên trái) rồi xóa node đó.
- Sau khi xóa, cần đảm bảo cây vẫn duy trì đúng các tính chất của cây AA bằng cách điều chỉnh level và thực hiện các thao tác skew và split khi cần thiết để cân bằng lại cây.

## B-Trees (Các loại cây B)
### 1. B-Tree (Cây B)

B-Tree là một cấu trúc dữ liệu cây cân bằng tự động, được sử dụng rộng rãi trong các hệ thống cơ sở dữ liệu và hệ thống tệp để lưu trữ và truy xuất dữ liệu một cách hiệu quả. B-Tree được thiết kế để giảm thiểu số lần truy cập đĩa, giúp tăng tốc độ truy xuất dữ liệu.

**Tính chất**
1. Mỗi node có thể chứa nhiều khóa (keys) và con trỏ (pointers) đến các node con.
2. Các khóa trong mỗi node được sắp xếp theo thứ tự tăng dần.
3. Mỗi node (trừ node gốc và node lá) có ít nhất ⌈m/2⌉ con trỏ, trong đó m là bậc của cây B-Tree. Mỗi node có nhiều nhất m con trỏ. 
4. Node gốc có thể có ít nhất 1 con trỏ nếu là node lá, và ít nhất 2 con trỏ nếu không phải là node lá.
5. Tất cả các node lá đều nằm ở cùng một mức.
![](/img/tree/b-tree.webp)
_B-Tree - Source: Programiz_

### 1. 2-3 Tree (Cây 2-3)
2-3 Tree là một loại cây tìm kiếm cân bằng tự động, trong đó mỗi node có thể chứa 2 hoặc 3 con trỏ và 1 hoặc 2 khóa.

**Tính chất**
1. Mỗi node có thể chứa 1 hoặc 2 khóa. Trong cây 2-3, mỗi node có thể là 2-node: chứa 1 khóa và 2 con trỏ hoặc 3-node: chứa 2 khóa và 3 con trỏ.
2. Các khóa trong mỗi node được sắp xếp theo thứ tự tăng dần.
3. Mỗi node có thể có 2 hoặc 3 con trỏ đến các node con.
4. Node gốc có ít nhất 2 con trỏ nếu không phải là node lá.
5. Tất cả các node lá đều nằm ở cùng một mức.
6. Cây 2-3 luôn duy trì tính cân bằng, đảm bảo chiều cao của cây là log(n).

![](/img/tree/23-tree.png)
_Cây 2 3_

**Các thao tác trên cây 2-3**

**1. Chèn (Insertion)**

1. Bắt đầu từ node gốc, tìm vị trí thích hợp để chèn khóa mới.
2. Nếu node hiện tại đã đầy (có 2 khóa), tách node đó thành hai node và đẩy khóa giữa lên node cha.
3. Lặp lại quá trình này cho đến khi tìm được vị trí thích hợp để chèn khóa mới.

**2. Xóa (Deletion)**

1. Bắt đầu từ node gốc, tìm khóa cần xóa.
2. Nếu khóa nằm trong node lá, xóa khóa đó.
3. Nếu khóa nằm trong node không phải là lá, thay thế khóa đó bằng khóa lớn nhất trong cây con bên trái hoặc khóa nhỏ nhất trong cây con bên phải, sau đó xóa khóa thay thế.
4. Nếu node hiện tại có ít hơn 1 khóa, mượn khóa từ node anh em hoặc hợp nhất với node anh em.

### 2. 2-3-4 Tree (Cây 2-3-4)

2-3-4 Tree là một loại cây tìm kiếm cân bằng tự động, trong đó mỗi node có thể chứa 2, 3 hoặc 4 con trỏ và 1, 2 hoặc 3 khóa.

**Tính chất**
1. Mỗi node có thể chứa 1, 2 hoặc 3 khóa. 2-node chứa 1 khóa và có 2 con trỏ. 3-node chứa 2 khóa và có 3 con trỏ. 4-node chứa 3 khóa và có 4 con trỏ.
2. Các khóa trong mỗi node được sắp xếp theo thứ tự tăng dần.
3. Mỗi node có thể có 2, 3 hoặc 4 con trỏ đến các node con.
4. Node gốc có ít nhất 2 con trỏ nếu không phải là node lá.
5. Tất cả các node lá đều nằm ở cùng một mức.
6. Cây 2-3-4 luôn duy trì tính cân bằng, đảm bảo chiều cao của cây là log(n).

**Các thao tác trên cây 2-3-4**

1. **Chèn (Insertion)**:
  - Bắt đầu từ node gốc, tìm vị trí thích hợp để chèn khóa mới.
  - Nếu node hiện tại đã đầy (có 3 khóa), tách node đó thành hai node và đẩy khóa giữa lên node cha.
  - Lặp lại quá trình này cho đến khi tìm được vị trí thích hợp để chèn khóa mới.

2. **Xóa (Deletion)**:
  - Bắt đầu từ node gốc, tìm khóa cần xóa.
  - Nếu khóa nằm trong node lá, xóa khóa đó.
  - Nếu khóa nằm trong node không phải là lá, thay thế khóa đó bằng khóa lớn nhất trong cây con bên trái hoặc khóa nhỏ nhất trong cây con bên phải, sau đó xóa khóa thay thế.
  - Nếu node hiện tại có ít hơn 2 khóa, mượn khóa từ node anh em hoặc hợp nhất với node anh em.

![](/img/tree/234-tree.png)
_Cây 2-3-4_

## Lời kết

Cảm ơn bạn đã vào đây và đọc bài viết này, đây chỉ là một nơi mình xem như tổng hợp và tìm hiểu các kiến thức mình mày mò hoặc học hỏi được, cũng như là một nơi để mình ôn lại bài nên có thể có sai sót nên các bạn chỉ nên tham khảo là chính. Các bạn có thể tham khảo các nguồn dưới đây của mình để tìm hiểu kỹ càng và cặn kẽ hơn nhé !!!

## Tài liệu tham khảo

[DSA Tree - W3schools](https://www.w3schools.com/dsa/dsa_theory_trees.php)

[What is a Binary Trees - Klu.ai](https://klu.ai/glossary/binary-tree?__cf_chl_rt_tk=9tcn3tDNsvzcC3H.1X7PQ1tcZN3mTwlsvThRAjEJAoI-1731054858-1.0.1.1-wycwbKu_cj0c8oOs1uY9TUVyfRFVj70Z7rp_QFWPw0I)

[Tree in DSA - Programiz](https://www.programiz.com/dsa/trees)

[Binary Tree - GeeksforGeeks](https://www.geeksforgeeks.org/binary-search-tree-data-structure/)

[Video của thầy Nguyễn Văn Sơn IT](https://www.youtube.com/@nguyenvansonit7503)

Giáo trình Giải Thuật Và Lập Trình - Thầy Lê Minh Hoàng

> Và một số nguồn khác...

_Have a nice day !!!_

_08/11/2024_

_Cừn_
