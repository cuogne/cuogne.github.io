---
description: >-
  Tìm hiểu về Tree (Cây) trong Data Structures and Algorithms (DSA)
title: Tree in DSA
date: 2024-11-08 12:00:00 +0700
categories: [Blog, Code]
---

Hello mn, hôm nay toi vừa fail bài test về cây huhu ;-; nên quyết định sẽ đi tổng hợp kiến thức bị hỏng của toi về cây lại tại đây. Mọi người đừng như tôi nhé :((

## **Cây là gì ?**

Theo lí thuyết đồ thị, cây là một đồ thị liên thông, vô hướng và không có chu trình.

Còn trong mặt cấu trúc dữ liệu và giải thuật, cây là một cấu trúc dữ liệu phi tuyến tính, tương tự như một linked list nhưng thay vì mỗi node chỉ đơn giản chỉ đến node tiếp theo theo kiểu tuyến tính, ở tree mỗi node trỏ đến một số node khác, phát triển theo nhiều nhánh và giúp biểu diễn các quan hệ phân cấp phức tạp. Giũa các node có quan hệ phân cấp gọi là cha - con (parent - child)

## **Tính chất và thành phần của cây**
### 1. Node
> Mỗi phần tử trong một cây được gọi là Node (hay nút)
{: .prompt-tip }

### 2. Root
> Mỗi cây đều có một node đặc biệt gọi là node root hay node gốc của cây. Node gốc là node không có cha.
{: .prompt-tip }

### 3. Parent
> Node trực tiếp kết nối và đứng ở cấp trên của nó gọi là node cha (parent).
{: .prompt-tip }

### 4. Child
> Node nằm bên dưới một node khác (cha) thì gọi là node con (child)
{: .prompt-tip }

### 5. Siblings
> Các node có cùng một cha (parent) gọi là anh em (siblings)
{: .prompt-tip }

> Một node con thì chỉ có thể có một node cha, nhưng một node cha thì có thể có nhiều node con.
{: .prompt-tip }

### 6. Leaf
> Node không có con gọi là node lá (leaf). Trong đồ thị thì nó gọi là đỉnh treo
{: .prompt-tip }

### 7. Path
> Là một dãy liên tiếp các node, trong đó mỗi node trỏ tới node con của nó. Một path có thể bắt đầu từ gốc (root) và kết thúc tại một node lá (leaf), hoặc từ một node bất kỳ đến một node bất kỳ khác trong cây.
{: .prompt-tip }

### 8. Order
> Bậc của một cây là số lượng node con tối đa có thể của node đó.
{: .prompt-tip }

> Ex: cây nhị phân (binary tree) thì chỉ có tối đa 2 con trên 1 node, tương tự với cây 3-phân,...
{: .prompt-tip }

### 9. Degree
> Bậc của một node là số lượng node con của một node cụ thể trong cây
{: .prompt-tip }

### 10. Height
> Chiều cao của cây (Height of the tree) là số cạnh trên đường đi dài nhất tính từ root đến một node lá (leaf)
{: .prompt-tip }

### 11. Level
> Mức của cây (level): Tập hợp tất cả các node ở một độ sâu nhất định được gọi là level của cây.
  > - Tại root của cây sẽ được gán level là 0
  > - Các node trực tiếp (node con của node gốc) là mức 1
  > - Các node con của node mức 1 là mức 2, cứ thế tiếp tục
  > - ...
{: .prompt-tip }

### 12. Depth
> Độ sâu của một node là số cạnh từ root đến node đó. Node gốc có độ sâu bằng 0.
  > - Lưu ý: Độ sâu và mức (level) thường có thể trùng nhau về giá trị nhưng khác nhau về ngữ nghĩa.
  > - Mức dùng để chỉ vị trí phân cấp, còn độ sâu dùng để chỉ khoảng cách từ gốc.
{: .prompt-tip }

### 13. Ancestor
> Một node được gọi là Ancestor (tổ tiên) (của node x nào đó trong cây) nếu nó nằm trên đường đi từ root tới node x.
  > - Node x cũng được coi là tổ tiên của chính nó (được gọi là tổ tiên bản thân hoặc trivial ancestor).
{: .prompt-tip }

### 14. Descendant
> Một node được gọi là Descendant (hậu duệ) (của node x nào đó trong cây) nếu nó nằm trên đường đi từ node x tới node lá (leaf)
  > - Node x cũng được coi là hậu duệ của chính nó (gọi là trivial descendant).
{: .prompt-tip }

### 15. Subtree
> Subtree (cây con) của một node x là một cây bao gồm một node con (nếu có) của x và tất cả các hậu duệ của node con đó.
{: .prompt-tip }

> Mỗi node trong cây đều là gốc của một cây con.
{: .prompt-tip }

### 16. Internal Node 
> Node trong (hay đỉnh trong) là node có ít nhất 1 con (tức là không phải node lá).
{: .prompt-tip }

### **Ví dụ minh họa**

![](/img/tree/treetest.png)
_Hình ảnh một cây(Tree)_

Như trên hình, ta có
> - Node [root](#2-root) là A (node không có node cha)
- Node [parent](#3-parent) của F là B (tức B là node cha của F - F là node con của B)
- Node [child](#4-child) của D là H (tức H là node con của D - D là node cha của H)
- I và J là 2 anh em ([siblings](#5-siblings)) và có cùng node cha là G
- [Leaf](#6-leaf): E, F, I, J, C, M, L (các node không có node con)
- [Path](#7-path): A -> B -> G -> J (một đường đi từ A -> J)
- [Order](#8-order) của cây trên hình là 3 (vì có node có bậc cao nhất là 3: A, B)
- [Degree](#9-degree) của H là 2 (vì H có 2 node con là K và L)
- [Height](#10-height) của cây trên hình là 4 (vì đường đi cạnh dài nhất từ root tới leaf là: A -> D -> H -> K -> M, có 4 cạnh)
- Các node có [Level](#11-level) = 2 là: E, F, G, H; [Level](#11-level) = 1 là B, C, D
- [Depth](#12-depth) của B, C, D là 1 (vì cách root A 1 path)
- [Ancestor](#13-ancestor) của node G là A và B (vì tồn tại đường đi A -> B -> G)
- [Descendant](#14-descendant) của node B chính là E, F, G, I và J
- [Subtree](#15-subtree) của D chính là cây con của D: gồm các Descendant: D, H, K, L, M
- [Internal Node](#16-internal-node) gồm: A, B, G, D, H, K (node không phải node lá)
{: .prompt-tip }

## **Binary Tree (Cây nhị phân)**

Có nhiều loại cây khác nhau như cây thông thường, cây k-phân (nhị phân, tam phân). Tuy nhiên, ở đây chúng ta sẽ tìm hiểu sâu vào cây nhị phân (Binary Tree)

Cây nhị phân (Binary Tree) là một cây mà mỗi nút của nó chỉ có tối đa 2 node con. Các node con đó cũng được phân biệt thành node con trái và node con phải. 

Biễu diễn và lưu trữ cây:

- Thành phần của một node trong cây nhị phân:

```c++
struct Node {
  int data;
  Node* left;
  Node* right;
}
```

- Với data: giá trị mà node đó lưu trữ
- Node* left: chứa địa chỉ (con trỏ) tới nút con bên trái
- Node* right: chứa địa chỉ (con trỏ) tới nút con bên phải

- Khi duyệt, chỉ cần quan tâm tới node root, vì từ root, ta có thể di chuyển sang left và right và duyệt mọi node khác

- Ngoài ra, bạn có thể sử dụng mảng (Array) để biểu diễn cây nhị phân bằng cách:
  - Xem cây đó là một cây nhị phân hoàn hảo (Perfect Binary Tree) (Phần này sẽ được đề cập bên dưới), tức là thêm một số node giả vào để tạo thành cây nhị phân hoàn hảo (Perfect Binary Tree) và gán các giá trị giả đó bằng rỗng (null)
  - Đánh số cho node gốc là 0
  - Di chuyển xuống mức kế tiếp, đánh số lần lượt từ trái sang phải đối với các nút ở mỗi mức, kể cả nút rỗng (null) (1,2,3,...) cho đến node lá ngoài cùng nhất trên mức sâu nhất của cây.

- Với cách đánh số này, con của node thứ i sẽ là 2*i+1 và 2*i+2
- => lưu trữ cây bằng 1 mảng a, với node thứ i sẽ nằm ở vị trí a[i]

Ví dụ với cây bên dưới, thay vì biểu diễn bằng cây, ta có thể làm thành mảng arr[]:
![](/img/tree/treeasarray.png)

Tuy nhiên không khuyến khích sử dụng vì có thể tốn thêm vùng nhớ nếu nó không phải là cây nhị phân hoàn chỉnh (Complete Binary Tree). Một trường hợp có thể sử dụng và hiệu quả đó là cấu trúc dữ liệu Heap và Heap Sort. Bạn có thể đọc thêm tại đây: [HeapSort](https://www.geeksforgeeks.org/heap-sort/)

## **Traversal Binary Tree (Duyệt cây nhị phân)**

Traversal (Duyệt cây) là duyệt qua tất cả các node trong cây theo một thứ tự nhất định, đảm bảo rằng mỗi node đều được thăm đúng một lần.
- Có 3 cách duyệt cây nhị phân thường được sử dụng:

### 1. Pre-Order Traversal - Tiền thứ tự (NLR)

- Bước 1: Duyệt từ node root trước
- Bước 2: Duyệt qua cây con trái (Left)
- Bước 3: Duyệt qua cây con phải (Right)

> Root -> Left -> Right
{: .prompt-tip }

Bên dưới là code C++ minh họa phép duyệt tiền thứ tự (NLR):

```c++
void NLR(Node* root){
  if (root){
    cout << root -> data <<" ";
    NLR(root -> left);
    NLR(root -> right);
  }
}
```

### 2. In-Order Traversal - Trung thứ tự (LNR)

- Bước 1: Duyệt từ cây con trái trước (Left Subtree)
- Bước 2: Duyệt qua node gốc (Root)
- Bước 3: Duyệt qua cây con phải (Right Subtree)

> Left -> Root -> Right
{: .prompt-tip }

Bên dưới là code C++ minh họa phép duyệt trung thứ tự (LNR):

```c++
void LNR(Node* root){
  if (root){
    LNR(root -> left);
    cout << root -> data <<" ";
    LNR(root -> right);
  }
}
```

### 3. Post-Order Traversal - Hậu thứ tự (LRN)

- Bước 1: Duyệt từ cây con trái trước (Left Subtree)
- Bước 2: Duyệt qua qua cây con phải (Right Subtree)
- Bước 3: Duyệt qua node gốc (Root)

> Left -> Right -> Root
{: .prompt-tip }

Bên dưới là code C++ minh họa phép duyệt hậu thứ tự (LRN):

```c++
void LRN(Node* root){
  if (root){
    LRN(root -> left);
    LRN(root -> right);
    cout << root -> data <<" ";
  }
}
```

### 4. Ví dụ minh họa phép duyệt cây nhị phân

![](/img/tree/binarysearchtree.png)
_Binary Tree_

> - Pre-Order Traversal: 50 20 10 5 15 30 80 75 90 85
- In-Order Traversal: 5 10 15 20 30 50 75 80 85 90
- Post-Order Traversal: 5 15 10 30 20 75 85 90 80 50
{: .prompt-tip }

- Ngoài ra các cách duyệt trên vẫn có thể áp dụng cho cây k-phân, bạn có thể đọc thêm tại đây: 
  - [Inorder Traversal of an n-ary tree](https://www.geeksforgeeks.org/inorder-traversal-of-an-n-ary-tree/)
  - [Preorder Traversal of an n-ary tree](https://www.geeksforgeeks.org/construct-full-k-ary-tree-preorder-traversal/)
  - [Postorder Traversal of an n-ary tree](https://www.geeksforgeeks.org/iterative-postorder-traversal-of-n-ary-tree/)

### 5. Polish Notation và Reverse Polish Notation

Một trong những ứng dụng của phép duyệt cây chính là Polish Notation (Ký pháp Ba Lan) và Reverse Polish Notation (Ký pháp Ba Lan ngược)

> Trước hết, ta có định nghĩa của cây nhị phân biểu thức (Binary expression tree) chính là cây nhị phân mà:
- Mỗi số được biểu diễn bởi 1 node lá (leaf)
- Mỗi đỉnh trong (node trong) biểu diễn một toán tử với 2 thành tố là 2 node con của đỉnh ấy
{: .prompt-tip }

Kết quả thu được sau khi duyệt cây nhị phân biểu thức bằng phép duyệt tiền thứ tự (Preorder Traversal) là tiền tố (gọi là Ký pháp Ba Lan - Polish Notation)

Tương tự như vậy với phép duyệt hậu thứ tự (Postorder Traversal) là hậu tố (gọi là Ký pháp Ba Lan ngược - Reverse Polish Notation)

Ví dụ minh họa cho cây nhị phân biểu thức:

![](/img/tree/binaryexpressiontree.png)
_Cây nhị phân biểu thức_

- Kết quả của phép duyệt tiền tự: 

```
+ ^ * 3 2 2 / 25 - 9 4
```

- Kết quả của phép duyệt hậu tự: 

```
3 2 * 2 ^ 25 9 4 - / +
```

Để tính các Ký pháp Ba Lan và Ký pháp Ba Lan ngược ở trên, ta sẽ dùng tính chất của stack để giải quyết:

+ Đối với Ký pháp Ba Lan

> - Duyệt từ phải sang trái.
- Nếu gặp toán hạng, đẩy vào stack.
- Nếu gặp toán tử, lấy các toán hạng cần thiết từ đỉnh stack, thực hiện phép toán, và đẩy kết quả trở lại stack.
- Kết quả cuối cùng sẽ nằm ở đỉnh stack sau khi duyệt hết biểu thức.
{: .prompt-tip }

+ Đối với Ký pháp Ba Lan ngược

> - Duyệt từ trái sang phải.
- Nếu gặp toán hạng (số), đẩy vào stack.
- Nếu gặp toán tử, lấy các toán hạng cần thiết từ đỉnh stack để thực hiện phép toán, sau đó đẩy kết quả trở lại stack.
- Sau khi duyệt hết biểu thức, kết quả cuối cùng sẽ nằm ở đỉnh stack.
{: .prompt-tip }

Demo sử dụng Stack
```
PostOrder Traversal
Biểu thức = 3 2 * 2 ^ 25 9 4 - / +
Stack = []

#L1
Biểu thức = 2 * 2 ^ 25 9 4 - / +
Stack = [3]

#L2
Biểu thức = * 2 ^ 25 9 4 - / +
Stack = [3, 2]

#L3
Biểu thức = 2 ^ 25 9 4 - / +
Stack = [3, 2, *]

Ở đây gặp toán tử, ta tính các số có trong stack với nhau, ở đây sẽ là 3 * 2 = 6
Sau khi tính xong thì pop các số và toán tử vừa tính ra, push 6 (là kết quả vừa xử lí) vào lại stack
Stack = [6]

#L4
Biểu thức = ^ 25 9 4 - / +
Stack = [6, 2]

#L5
Biểu thức = 25 9 4 - / +
Stack = [6, 2, ^]

Lại gặp toán hạng, ta xử lí: 6 ^ 2 = 36, pop 6,2,^ ra, push 36 vào stack
Stack = [36]

#L6
Biểu thức = 9 4 - / +
Stack = [36, 25]

#L7
Biểu thức = 4 - / +
Stack = [36, 25, 9]

#L8
Biểu thức = - / +
Stack = [36, 25, 9, 4]

#L9
Biểu thức = / +
Stack = [36, 25, 9, 4, -]

Ở đây ta xử lí 9 - 4 = 5, sau đó pop 9, 4, - ra và push 5 vào
Stack = [36, 25, 5]

#L10
Biểu thức = +
Stack = [36, 25, 5, /]

Tương tự, 25/5 = 5, pop 25,5,/, push 5 vào
Stack = [36,5]

#L11
Biểu thức = 
Stack = [36 5 +] => 36 + 5 = 41, pop 36,5,+, push 41 vào
Thuật toán dừng lại do biểu thức đã hết toán tử và toán hạng 
Stack = [41], trả kết quả đỉnh stack là 41 
```

+ Đối với cách làm nhanh (trên giấy hoặc nhẩm)

> Gặp phép toán thì lấy 2 giá trị liền kề trước đó (hoặc sau đó) để tính xong viết lại kết quả vừa tính vào biểu thức
{: .prompt-tip }

Demo cách nhẩm/làm giấy

```
PostOrder Traversal
3 2 * 2 ^ 25 9 4 - / +
=> (3 * 2) 2 ^ 25 (9 - 4) / +
=> 6 2 ^ 25 5 / +
=> (6^2) (25 / 5) +
=> 36 5 +
=> (36 + 5) = 41
```

Ở trên là Demo về các cách tính biểu thức từ phép duyệt hậu tự, các bạn có thể tự làm với phép duyệt tiền tự (nhớ tuân theo quy tắc duyệt ở trên mình đã đề cập)

## **Các biến thể của Binary Tree**

### 1. Binary Trees (Các loại cây nhị phân)

#### a. Degenerate/Skewed Binary Tree (Cây nhị phân suy biến/lệch)
#### b. Complete Binary Tree (Cây nhị phân hoàn chỉnh)
#### c. Full Binary Tree (Cây nhị phân đầy đủ)
#### d. Perfect Binary Tree (Cây nhị phân hoàn hảo)

### 2. Binary Search Tree (BST - Cây nhị phân tìm kiếm)

### 3. Balanced Binary Tree (Cây nhị phân cân bằng)

#### a. AVL Tree (Adelson-Velsky Landis - Cây AVL)
#### b. Red-Black Tree (Cây đỏ-đen)
#### c. AA Tree (Arne Andersson - Cây AA)

### 4. B-Trees (Các loại cây B)

#### a. 2-3 Tree (Cây 2-3)
#### b. 2-3-4 Tree (Cây 2-3-4)

## Lời kết

## Tài liệu tham khảo

[DSA Tree](https://www.w3schools.com/dsa/dsa_theory_trees.php)

[What is a Binary Trees](https://klu.ai/glossary/binary-tree?__cf_chl_rt_tk=9tcn3tDNsvzcC3H.1X7PQ1tcZN3mTwlsvThRAjEJAoI-1731054858-1.0.1.1-wycwbKu_cj0c8oOs1uY9TUVyfRFVj70Z7rp_QFWPw0I)

Giáo trình Giải Thuật Và Lập Trình - Thầy Lê Minh Hoàng

_08/11/2024_

_Cừn_
